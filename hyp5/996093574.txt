the command design pattern is one of the twenty-three well-known design patterns that describe how to solve recurring design problems to design flexible and reusable object-oriented software , that is , objects that are easier to implement , change , test , and reuse it should be possible to configure an object ( that invokes a request ) with a request implementing ( hard-wiring ) a request directly into a class is inflexible because it couples the class to a particular request at compile-time , which makes it impossible to specify a request at run-time using the command design pattern describes the following solution : define separate ( command ) objects that encapsulate a request this enables one to configure a class with a command object that is used to perform a request instead , invoker refers to the command interface to perform a request ( command.execute ( ) ) , which makes the invoker independent of how the request is performed the command1 class implements the command interface by performing an action on a receiver ( receiver1.action1 ( ) ) in addition to the ability to perform the desired command , an may have an associated icon , keyboard shortcut , tooltip text , and so on ; macro recording : if all user actions are represented by command objects , a program can record a sequence of actions simply by keeping a list of the command objects as they are executed if the program embeds a scripting engine , each command object can implement a method , and user actions can then be easily recorded as scripts ; mobile code : using languages such as java where code can be streamed/slurped from one location to another via urlclassloaders and codebases the commands can enable new behavior to be delivered to remote locations ( ejb command , master worker ) ; parallel processing : where the commands are written as tasks to a shared resource and executed by many threads in parallel ( possibly on remote machines ; this variant is often referred to as the master/worker pattern ) ; progress bars : suppose a program has a sequence of commands that it executes in order typically these objects implement a common interface such as that allows the thread pool to execute the command even though the thread pool class itself was written without any knowledge of the specific tasks for which it would be used for example , move up , move up may refer to a single ( move up ) command that should be executed twice , or it may refer to two commands , each of which happens to do the same thing ( move up ) note that using a separate object for each invocation of a command is also an example of the chain of responsibility pattern the receiver object owns the method that is called by the command 's execute method command object , routed event arguments , event object : the object that is passed from the source to the command/action object , to the target object to the code that does the work command manager , undo manager , scheduler , queue , dispatcher , invoker : an object that puts command/event objects on an undo stack or redo stack , or that holds on to command/event objects until other objects are ready to act on them , or that routes the command/event objects to the appropriate receiver/target object or handler code 
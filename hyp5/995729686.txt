in this system , the verifier is a deterministic , polynomial-time machine ( a p machine ) the protocol is : the prover looks at the input and computes the solution using its unlimited power and returns a polynomial-size proof certificate in the case where a valid proof certificate exists , the prover is always able to make the verifier accept by giving it that certificate in the case where there is no valid proof certificate , however , the input is not in the language , and no prover , however malicious it is , can convince the verifier otherwise , because any proof certificate will be rejected although np may be viewed as using interaction , it was n't until 1985 that the concept of computation through interaction was conceived ( in the context of complexity theory ) by two independent groups of researchers in this presentation , arthur ( the verifier ) is a probabilistic , polynomial-time machine , while merlin ( the prover ) has unbounded resources also , instead of requiring that the verifier always accept valid certificates and reject invalid certificates , it is more lenient : completeness : if the string is in the language , the prover must be able to give a certificate such that the verifier will accept with probability at least 2/3 ( depending on the verifier 's random choices ) soundness : if the string is not in the language , no prover , however malicious , will be able to convince the verifier to accept the string with probability exceeding 1/3 in the same conference where babai defined his proof system for ma , shafi goldwasser , silvio micali and charles rackoff extended abstract published a paper defining the interactive proof system ipf ( n ) in each round , the verifier performs computation and passes a message to the prover , and the prover performs computation and passes information back to the verifier for example , in an ip3 protocol , the sequence would be vpvpvpv , where v is a verifier turn and p is a prover turn in arthur–merlin protocols , babai defined a similar class amf ( n ) which allowed f ( n ) rounds , but he put one extra condition on the machine : the verifier must show the prover all the random bits it uses in its computation the essential problem with public coins is that if the prover wishes to maliciously convince the verifier to accept a string which is not in the language , it seems like the verifier might be able to thwart its plans if it can hide its internal state from it showed , perhaps surprisingly , that the verifier 's ability to hide coin flips from the prover does it little good after all , in that an arthur–merlin public coin protocol with only two more rounds can recognize all the same languages to demonstrate the power of these classes , consider the graph isomorphism problem , the problem of determining whether it is possible to permute the vertices of one graph so that it is identical to another graph just as it 's easier to tell if a criminal is lying if he and his partner are interrogated in separate rooms , it 's considerably easier to detect a malicious prover trying to trick the verifier into accepting a string not in the language if there is another prover it can double-check with moreover , a mip protocol can recognize all languages in ip in only a constant number of rounds , and if a third prover is added , it can recognize all languages in nexptime in a constant number of rounds , showing again its power over ip 
in vector-based graphics editing , each leaf node in a scene graph represents some atomic unit of the document , usually a shape such as an ellipse or bezier path although shapes themselves ( particularly paths ) can be decomposed further into nodes such as spline nodes , it is practical to think of the scene graph as composed of shapes rather than going to a lower level of representation the document then becomes a set of layers , any of which can be conveniently made invisible , dimmed , or locked ( made read-only ) if differences are needed , a common type declaration in c++ would be to make a generic node class , and then derive layers and groups as subclasses a visibility member , for example , would be a feature of a layer , but not necessarily of a group for instance , a game might define a logical relationship between a knight and a horse so that the knight is considered an extension to the horse in our example above , each knight is a separate scene node , but the graphical representation of the knight ( made up of a 3d mesh , textures , materials and shaders ) is instanced this means that only a single copy of the data is kept , which is then referenced by any 'knight ' nodes in the scene graph the simplest form of scene graph uses an array or linked list data structure , and displaying its shapes is simply a matter of linearly iterating the nodes one by one for example , in a render operation , a transformation group node would accumulate its transformation by matrix multiplication , vector displacement , quaternions or euler angles in object-oriented languages such as c++ , this can easily be achieved by virtual functions , where each represents an operation that can be performed on a node the operation can be realised as a class that is passed to the current node ; it then queries the node 's type using rtti and looks up the correct operation in an array of callbacks or functors one alternative is scene graph rebuilding , where the scene graph is rebuilt for each of the operations performed a traversal generally consists of starting at some arbitrary node ( often the root of the scene graph ) , applying the operation ( s ) ( often the updating and rendering operations are applied one after the other ) , and recursively moving down the scene graph ( tree ) to the child nodes , until a leaf node is reached in 3d systems , which often employ depth buffers , it is more efficient to draw the closest objects first , since farther objects often need only be depth-tested instead of actually rendered , because they are occluded by nearer objects at the bottom of the hierarchy , the size of the volume is just large enough to encompass a single object tightly ( or possibly even some smaller fraction of an object in high resolution bvhs ) if an object 's bounding volume does not intersect a volume higher in the tree , it can not intersect any object below that node ( so they are all rejected very quickly ) an effective way of combining space partitioning and scene graphs is by creating a scene leaf node that contains the spatial partitioning data if the user has magnified a document so that only part of it is visible on his computer screen , and then scrolls in it , it is useful to use a bounding box ( or in this case , a bounding rectangle scheme ) to quickly determine which scene graph elements are visible and thus actually need to be drawn it is an iso-ratified standard that provides a system for the storage , retrieval and playback of real-time graphics content embedded in applications , all within an open architecture to support a wide array of domains and user scenarios 